Bitwise operators - & (and) , | (or), ~(not), << (left shift), >> (right shift), ^(XOR) 
=> they automatically convert a normal int (n)into binary so no need to convert first. actually reality is - The "No Conversion" Rule
* Storage: Integers (int, long) are always stored as binary in memory.
* Display: They only look like "decimals" because System.out.println formats them for us.
* Performance: Bitwise ops are the fastest operations because they work directly on this raw memory without translation.

### 1. Cheat Sheet Summary: Odd vs. Even

**The Logic:**

* **Binary Construction:** Every number is a sum of powers of 2 ().
* **The Even Rule:** All powers of 2 from  onwards () are **even**.
* **The Odd Exception:** Only  () is **odd**.
* **Conclusion:** If the 0th bit (Least Significant Bit) is `1`, the number is Odd. If `0`, it's Even.
* **The Operator:** `& 1` masks all bits except the 0th bit.

**The Code:**

```java
// Check if n is Odd
if ((n & 1) == 1) { ... } basically something like this (...10101 & ..0001) == 1(i.e 0001) - odd  

// Check if n is Even
if ((n & 1) == 0) { ... }

```

---

### 2. Java Data Types (Size & Limits)

For LeetCode, memorizing the "Power of 2" is often more useful than the exact number, as constraints are usually defined in powers (e.g., ).

| Type | Bit Size | Min Value () | Max Value () 

| **int** | **32 bits** | - 2 power 31|  2 power 31 - 1
| **long** | **64 bits** |-2 power 63  | 2 power 63 - 1  

3. Quick Tips for LeetCode
* The "2 Billion" Rule: If a problem says the input can be up to 10^9 or 2 * 10^9, it fits in an int. If it goes up to 10^{10} or higher, you must use long or you will get an integer overflow error.
* The L suffix: In Java, always add 'L' when initializing a long literal (e.g., long num = 10000000000L;) otherwise Java treats it as an int and might error out if it's too big.



*)mark means a variable. bit referes to bit operator means works on 0 and 1.

*) && , ||, ! are logical operator .  & and ! are bitwise operator , they are faster than logical operator.


*)Left shift : 5 << 3 = 5 * 2 ^ 3 : 20
for -ve
 -5 << 3 = -5 * 2 ^ 3 : -20. 

*)Right Shift : 5 >> 3 = 5 / 2 ^ 3 and 17 >> 2 = 4 
for -ve (positive ans + 1) i.e -17 >> 2 = -5

*)xor(^) : same = 0 and different = 1
0 0 0
1 1 0
1 0 1
0 1 1


*) other bitwise are ^ (xor) if same than 0 otherwise 1 (ex - 0 0 = 0 and 1 0 = 1). and ~ not operator basically complement same as logical not but it work on 0 and 1.

- xor property - if xor taken from 0 we get same number , if xor of same number taken than its 0 and associative property.


*) n & 1 and n % 2 is same thing

*)unset bit means 0 and set bit means 1

*) suppose x is number like 01010101100 and need to clear last bit means from last i need to make 1 as 0 so just take x & x -1 we will get 01010101000.