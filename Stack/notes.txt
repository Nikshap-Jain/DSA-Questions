1) Stack - lifo : primitive class in heap 
- methods : peek (get first element, top element) , pop (delete), push (add element on top), size, isEmpty(check if stack empty or not).

ex - Stack<Integer> st = new Stack<>();
    sout(st.capacity()) // by default 10'
    st.push(10); add 10
    st.push(20);
    st.push(30);
    st.peek(); view top element
    st.size(); 3
    st.isEmpty(); false

    accesss by for each loop -  for (int v : st){
        sout(v) // output - 10, 20 , 30 
    }

2) In stack vector are used internally which make it synchronous (thread safe).

3)If question is to add element at last or mid in stack without creation of other stack or other data structure than use backtracking to empty and add and then push again.

4) Monotonic stack (strictly increasing or decreasing via element) question - classical questions : next greater, next smaller, prev greater etc. 

5) Dynamic mai inherit kr denge.
default - outside package accesseble nhi hai 
protected - outside package se accessible nhi hai but inheritable hai.

- Pattern 321
- daily temp
- strawed  collision.
- 1793



Stack

In LeetCode, a Stack is a Last-In, First-Out (LIFO) data structure. Think of it as a stack of plates: you put a new plate on the top, and you also take a plate from the top.

‚öôÔ∏è How to Create a Stack

You can use the standard Stack class. (See the "Pro-Tip" at the end for the faster way).
Java


import java.util.Stack;

// Create a stack of integers
Stack<Integer> stack = new Stack<>();

// Create a stack of characters (common for parentheses)
Stack<Character> charStack = new Stack<>();


üöÄ Core Methods

These are the three methods you'll always use.
Important: Unlike the "safe" Queue methods, pop() and peek() will throw an exception if the stack is empty. You must check isEmpty() first.
* stack.push(value);
    * What it does: Adds an element to the top of the stack.
    * Example: stack.push(5);
* stack.pop();
    * What it does: Removes and returns the element from the top of the stack.
    * Throws: EmptyStackException if the stack is empty.
    * Example: int topElement = stack.pop();
* stack.peek();
    * What it does: Looks at the element at the top of the stack without removing it.
    * Throws: EmptyStackException if the stack is empty.
    * Example: int topElement = stack.peek();


üõ†Ô∏è Helper Methods (The "Safe" Way)

* stack.isEmpty();
    * What it does: Returns true if the stack is empty. You must use this before calling pop() or peek() to avoid crashing your code.
* stack.size();
    * What it does: Returns the number of elements in the stack.


Pattern: Valid Parentheses / Backtracking

This is the #1 use case for a Stack on LeetCode. It's used for any problem involving "matching" pairs (like parentheses) or "backtracking" (like an iterative Depth-First Search).
Here is the standard template for Valid Parentheses (LeetCode 20):
Java




public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();

    // Loop through every character in the string
    for (char c : s.toCharArray()) {
        
        // If it's an opening bracket, push the
        // *corresponding closing bracket* onto the stack.
        if (c == '(') {
            stack.push(')');
        } else if (c == '{') {
            stack.push('}');
        } else if (c == '[') {
            stack.push(']');
        }
        
        // If it's a closing bracket...
        else {
            // Check for two error cases:
            // 1. Stack is empty (e.g., "}")
            // 2. Top of stack doesn't match (e.g., "(]")
            if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }
    }
    
    // If the stack is empty at the end, all brackets matched.
    return stack.isEmpty();
}


‚≠ê Pro-Tip: Use Deque for a Faster Stack

The Stack class you saw above is old, slow, and "legacy."
In modern Java and high-performance LeetCode solutions, we use a Deque (Double-Ended Queue) implemented with ArrayDeque. It's faster and more flexible.
* How to create:‚Ä®Java‚Ä®‚Ä®‚Ä®‚Ä®‚Ä®import java.util.ArrayDeque;
* import java.util.Deque;
* 
* // This is the "pro" way to make a stack
* Deque<Integer> stack = new ArrayDeque<>();
* ‚Ä®‚Ä®‚Ä®‚Ä®
* The methods are the same:
    * stack.push(value);
    * stack.pop(); (Still throws exception if empty)
    * stack.peek(); (Returns null if empty, which is safer!)
    * stack.isEmpty();
For LeetCode, Stack<Integer> s = new Stack<>(); is fine. But if you want to be "correct" and faster, use Deque<Integer> s = new ArrayDeque<>();.
