*)It is finite Set of edge and vertex.
*)all trees are graphs but all graphs are not tree because in tree there is no cycle and its connected.
*)Two types of graph - directed and undirected (now they are also divided into subcategories called weighted and unweighted graph)

*)Graphs store as 
-Adjacency Matrix (we don't use it because of wastage of storage)

-Adjacency List (don't use it because of increase in tc for traversal)

-Hashmap (best , we use this when weight is given otherwise list)

*)Complete graph : every vertex is connected to all vertex. in this if there is n vertex than edges are n(n - 1)/2


*)two search algorithm - bfs (level by level (queue)) and dfs (recursion so to replace it need to use stack isme ek path ko pkad lia pehele usse explore kro than dusra)
- remember these 5 things in bfs and dfs :and rule : Never mark things as visited until you pull them OUT (Step1).
remove,ignore,markedvisted, SelfWord, Add UnVisited in queue 
- when question ask shortest path we will do bfs.

Graph ka BFS bhi bilkul same hai! Bas ek twist hai: Tree mein raste kabhi wapis upar nahi jaate, lekin Graph mein raste "Gol" ghum sakte hain (Cycles).

Imagine kar Graph ek Tree hi hai, bas uski tehniyan (branches) aapas mein jud gayi hain. Isliye humein Visited set chahiye hota haiâ€”taaki hum gol-gol na ghoomein

*)Disconnected graph : component more than one (a dfs or bfs traverse over one component)

- We use BFT and DFT : BreathfirstTraversal (bsf in loop) and DepthFirstTraversal (dfs in loop) to get all vertex of Disconnected graph

*)A graph is a tree when its acyclic and have single component.

*)Bipartite : if it is possible to divide graph in two independent sets such that element within the set are not connected. (also if we need to put two color on the vertices such that two adjacent vertices don't have same colour is implementation of bipartite if it is possible to do it than also graph is bipartite) 

- All acyclic graphs are bipartite.All even cylic (total edges are even) are always bipartite and if we get a single odd cycle than graph is never bipartite.

*)Spanning tree : subset of graph which has minimum number of edges and all vertices are connected.A graph can have more than one spanning tree , edges are n -1 in all spanning trees of a graph.

- minimum spanning tree : spanning tree which has least weight it can be found by two algo kruskal and prims. both implementation give same time complexity. krushkal is implemented using DSU(competitive programming concept) so we will not do it use prims always.

-Dijkstra : It will give shortest path from source to all vertext (and it will be connected because disconnected hoga toh kaise hi access hogaa) . Its code same as prims just we need to add previous cost and in place of aquiring vertex we need to take string so that we can print the path.

1. Dijkstra's Algorithm
Graph Type: Works on both Directed and Undirected.

Constraint: NO Negative Edges.

Why? It is a "Greedy" algorithm. It assumes that adding an edge to a path can only increase (or keep equal) the total cost. A negative edge breaks this rule.

2. Bellman-Ford Algorithm
Graph Type: Works on both Directed and Undirected.

Constraint: NO Negative Cycles.

The Catch with Undirected Graphs: If you have an undirected graph with a negative edge, Bellman-Ford will fail (or rather, detect a negative cycle immediately).

Reason: An undirected edge A - B with weight -2 is actually two directed edges: A -> B (-2) and B -> A (-2).Going back and forth (A -> B -> A) gives a cost of -4. This is an infinite negative loop.So: Bellman-Ford on an undirected graph effectively means no negative edges allowed at all.

